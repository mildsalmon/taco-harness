#!/usr/bin/env bash
# taco.sh — Unified CLI for taco-claude pipeline
# Usage: ./scripts/taco.sh <command> [args]
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

source "$SCRIPT_DIR/lib/common.sh"
source "$SCRIPT_DIR/event-log.sh"
source "$SCRIPT_DIR/gate.sh"
source "$SCRIPT_DIR/call-model.sh"

usage() {
  cat <<'USAGE'
taco-claude CLI

Usage:
  taco.sh init <project-dir>                Initialize .dev/ in a project
  taco.sh feature new <project-dir> <name>  Create feature scaffold
  taco.sh feature list <project-dir>        List existing features
  taco.sh gate check <G1|G2|G3> <project-dir> <feature>
                                            Check pipeline gate
  taco.sh pack list <project-dir>           List available domain packs
  taco.sh pack status <project-dir>         Show enabled packs
  taco.sh pack enable <project-dir> <pack>  Enable a domain pack
  taco.sh pack disable <project-dir> <pack> Disable a domain pack
  taco.sh model check                       Check external model availability
  taco.sh model doctor                      Probe models with test prompt
  taco.sh state show <project-dir>          Show current pipeline state
  taco.sh events <project-dir> [n]          Show last n events (default 20)
  taco.sh help                              Show this help
USAGE
}

die() {
  printf '[ERROR] %s\n' "$*" >&2
  exit 1
}

cmd_init() {
  [[ $# -eq 1 ]] || die "init requires <project-dir>"
  local project_dir="$1"

  mkdir -p "$project_dir/.dev/specs"
  [[ -f "$project_dir/.dev/state.json" ]] || echo '{}' > "$project_dir/.dev/state.json"
  [[ -f "$project_dir/.dev/events.jsonl" ]] || : > "$project_dir/.dev/events.jsonl"

  # Ensure .dev/ is in .gitignore
  if [[ -f "$project_dir/.gitignore" ]]; then
    if ! grep -qF '.dev/' "$project_dir/.gitignore"; then
      echo '.dev/' >> "$project_dir/.gitignore"
    fi
  fi

  # Ensure docs/learnings/ exists
  mkdir -p "$project_dir/docs/learnings"

  log_event "$project_dir" "runtime_init" "" "initialized via taco.sh"
  echo "[INFO] initialized: $project_dir/.dev/" >&2
}

cmd_feature_new() {
  [[ $# -eq 2 ]] || die "feature new requires <project-dir> <name>"
  local project_dir="$1"
  local name="$2"

  # Normalize: lowercase, spaces to dashes
  name=$(printf '%s' "$name" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g' | head -c 64)

  local spec_dir="$project_dir/.dev/specs/$name"
  [[ ! -d "$spec_dir" ]] || die "feature already exists: $name"

  mkdir -p "$spec_dir/reviews"

  # Create placeholder files
  for f in idea.md spec.md plan.md; do
    if [[ ! -f "$spec_dir/$f" ]]; then
      echo "# ${f%.md} — $name" > "$spec_dir/$f"
      echo "" >> "$spec_dir/$f"
      echo "_To be generated by the pipeline._" >> "$spec_dir/$f"
    fi
  done

  # Create tasks tracker from template if available
  local tasks_tmpl="$ROOT/templates/TASKS_TEMPLATE.md"
  if [[ -f "$tasks_tmpl" ]]; then
    sed "s/{feature-name}/$name/g; s/{Feature Name}/$name/g" "$tasks_tmpl" > "$spec_dir/tasks.md"
  fi

  # Create verify report from template if available
  local verify_tmpl="$ROOT/templates/VERIFY_REPORT_TEMPLATE.md"
  if [[ -f "$verify_tmpl" ]]; then
    sed "s/{feature-name}/$name/g; s/{Feature Name}/$name/g" "$verify_tmpl" > "$spec_dir/reviews/verify-report.md"
  fi

  log_event "$project_dir" "feature_created" "$name" "feature scaffold created"
  echo "[INFO] feature created: $name" >&2
  echo "[INFO] spec dir: $spec_dir" >&2
}

cmd_feature_list() {
  [[ $# -eq 1 ]] || die "feature list requires <project-dir>"
  local project_dir="$1"
  local specs_dir="$project_dir/.dev/specs"

  if [[ ! -d "$specs_dir" ]]; then
    echo "(no features)"
    return 0
  fi

  for d in "$specs_dir"/*/; do
    [[ -d "$d" ]] || continue
    local name
    name=$(basename "$d")
    local status="unknown"

    # Determine status from state.json
    if [[ -f "$project_dir/.dev/state.json" ]]; then
      local current_feature
      current_feature=$(jq -r '.feature // empty' "$project_dir/.dev/state.json" 2>/dev/null)
      local current_stage
      current_stage=$(jq -r '.stage // empty' "$project_dir/.dev/state.json" 2>/dev/null)
      if [[ "$current_feature" == "$name" && -n "$current_stage" ]]; then
        status="$current_stage"
      fi
    fi

    printf '%-30s %s\n' "$name" "$status"
  done
}

cmd_state_show() {
  [[ $# -eq 1 ]] || die "state show requires <project-dir>"
  local project_dir="$1"
  local state_file="$project_dir/.dev/state.json"

  if [[ ! -f "$state_file" ]]; then
    echo "No pipeline state (run init first)"
    return 0
  fi

  echo "=== Pipeline State ==="
  jq '.' "$state_file" 2>/dev/null || cat "$state_file"
}

cmd_pack_list() {
  [[ $# -eq 1 ]] || die "pack list requires <project-dir>"
  local project_dir="$1"
  local domains_dir="$project_dir/domains"

  if [[ ! -d "$domains_dir" ]]; then
    echo "(no domain packs)"
    return 0
  fi

  for d in "$domains_dir"/*/; do
    [[ -d "$d" ]] || continue
    local name
    name=$(basename "$d")
    local enabled=""
    local packs_file="$project_dir/.dev/enabled_packs"
    if [[ -f "$packs_file" ]] && grep -Fxq "$name" "$packs_file" 2>/dev/null; then
      enabled=" [enabled]"
    fi
    printf '%s%s\n' "$name" "$enabled"
  done
}

cmd_pack_status() {
  [[ $# -eq 1 ]] || die "pack status requires <project-dir>"
  local project_dir="$1"
  local packs_file="$project_dir/.dev/enabled_packs"

  if [[ ! -f "$packs_file" ]]; then
    echo "(no packs enabled)"
    return 0
  fi

  echo "=== Enabled Packs ==="
  grep -Ev '^\s*#|^\s*$' "$packs_file" 2>/dev/null || echo "(none)"
}

cmd_pack_enable() {
  [[ $# -eq 2 ]] || die "pack enable requires <project-dir> <pack-name>"
  local project_dir="$1" pack="$2"

  [[ -d "$project_dir/domains/$pack" ]] || die "unknown pack: $pack"

  ensure_dir "$project_dir/.dev"
  ensure_line_in_file "$project_dir/.dev/enabled_packs" "$pack"
  log_event "$project_dir" "pack_enabled" "" "$pack"
  echo "[INFO] pack enabled: $pack" >&2
}

cmd_pack_disable() {
  [[ $# -eq 2 ]] || die "pack disable requires <project-dir> <pack-name>"
  local project_dir="$1" pack="$2"

  remove_line_from_file "$project_dir/.dev/enabled_packs" "$pack"
  log_event "$project_dir" "pack_disabled" "" "$pack"
  echo "[INFO] pack disabled: $pack" >&2
}

cmd_model_check() {
  echo "=== Model Availability ==="
  check_models
}

cmd_model_doctor() {
  echo "=== Model Doctor ==="
  echo ""

  local healthy_count=0 total=2

  # --- Claude (host model, always available) ---
  echo "[Claude]"
  echo "  Status:   OK (host model)"
  echo "  Model:    claude-opus-4-6 / claude-sonnet-4-6"
  echo ""

  # --- Launch probes in parallel ---
  local codex_tmp gemini_tmp
  codex_tmp=$(mktemp "${TMPDIR:-/tmp}/taco-probe-codex.XXXXXX")
  gemini_tmp=$(mktemp "${TMPDIR:-/tmp}/taco-probe-gemini.XXXXXX")

  local codex_available=false gemini_available=false
  _model_available "codex" && codex_available=true
  _model_available "gemini" && gemini_available=true

  # Start probes in background
  if $codex_available; then
    probe_codex > "$codex_tmp" 2>/dev/null &
    local codex_pid=$!
  fi
  if $gemini_available; then
    probe_gemini > "$gemini_tmp" 2>/dev/null &
    local gemini_pid=$!
  fi

  echo "  Probing models in parallel..."
  echo ""

  # Wait for both
  if $codex_available; then
    wait "$codex_pid" 2>/dev/null || true
  fi
  if $gemini_available; then
    wait "$gemini_pid" 2>/dev/null || true
  fi

  # --- Display Codex results ---
  echo "[Codex]"
  if $codex_available; then
    echo "  CLI:      Found ($(command -v codex))"
    echo "  Model:    gpt-5.3-codex (xhigh effort)"

    local codex_result codex_status codex_latency codex_response
    codex_result=$(cat "$codex_tmp")
    codex_status=$(printf '%s' "$codex_result" | jq -r '.status' 2>/dev/null || echo "error")
    codex_latency=$(printf '%s' "$codex_result" | jq -r '.latency_ms' 2>/dev/null || echo "?")
    codex_response=$(printf '%s' "$codex_result" | jq -r '.response' 2>/dev/null || echo "")

    if [[ "$codex_status" == "healthy" ]]; then
      echo "  Probe:    healthy (${codex_latency}ms)"
      echo "  Response: \"${codex_response}\""
      healthy_count=$((healthy_count + 1))
    else
      echo "  Probe:    DEGRADED (${codex_latency}ms)"
      [[ -n "$codex_response" ]] && echo "  Response: \"${codex_response}\""
      echo "  Hint:     Check API key: codex auth status"
    fi
  else
    echo "  CLI:      NOT FOUND"
    echo "  Hint:     Install: npm i -g @openai/codex"
  fi
  echo ""

  # --- Display Gemini results ---
  echo "[Gemini]"
  if $gemini_available; then
    echo "  CLI:      Found ($(command -v gemini))"
    echo "  Model:    gemini-2.5-pro"

    local gemini_result gemini_status gemini_latency gemini_response
    gemini_result=$(cat "$gemini_tmp")
    gemini_status=$(printf '%s' "$gemini_result" | jq -r '.status' 2>/dev/null || echo "error")
    gemini_latency=$(printf '%s' "$gemini_result" | jq -r '.latency_ms' 2>/dev/null || echo "?")
    gemini_response=$(printf '%s' "$gemini_result" | jq -r '.response' 2>/dev/null || echo "")

    if [[ "$gemini_status" == "healthy" ]]; then
      echo "  Probe:    healthy (${gemini_latency}ms)"
      echo "  Response: \"${gemini_response}\""
      healthy_count=$((healthy_count + 1))
    else
      echo "  Probe:    DEGRADED (${gemini_latency}ms)"
      [[ -n "$gemini_response" ]] && echo "  Response: \"${gemini_response}\""
      echo "  Hint:     Check auth: gemini auth status"
    fi
  else
    echo "  CLI:      NOT FOUND"
    echo "  Hint:     Install: see https://github.com/google-gemini/gemini-cli"
  fi
  echo ""

  # Cleanup
  rm -f "$codex_tmp" "$gemini_tmp"

  # --- Verdict ---
  if [[ $healthy_count -eq $total ]]; then
    echo "Verdict: ALL HEALTHY ($healthy_count/$total)"
  elif [[ $healthy_count -gt 0 ]]; then
    echo "Verdict: PARTIAL ($healthy_count/$total healthy)"
  else
    echo "Verdict: DEGRADED (0/$total — Claude-only mode)"
  fi
}

cmd_events() {
  [[ $# -ge 1 ]] || die "events requires <project-dir> [n]"
  local project_dir="$1"
  local count="${2:-20}"
  local log_file="$project_dir/.dev/events.jsonl"

  if [[ ! -f "$log_file" ]]; then
    echo "No events yet"
    return 0
  fi

  echo "=== Last $count Events ==="
  tail -n "$count" "$log_file" | jq -r '"\(.ts)  \(.event)  \(.feature)  \(.details)"' 2>/dev/null || \
  tail -n "$count" "$log_file"
}

# Main dispatch
cmd="${1:-help}"
case "$cmd" in
  init)
    shift; cmd_init "$@" ;;
  feature)
    [[ $# -ge 2 ]] || die "feature requires subcommand"
    sub="$2"; shift 2
    case "$sub" in
      new)  cmd_feature_new "$@" ;;
      list) cmd_feature_list "$@" ;;
      *)    die "unknown feature subcommand: $sub" ;;
    esac
    ;;
  gate)
    [[ $# -ge 2 ]] || die "gate requires subcommand"
    sub="$2"; shift 2
    case "$sub" in
      check) gate_check "$@" ;;
      *)     die "unknown gate subcommand: $sub" ;;
    esac
    ;;
  pack)
    [[ $# -ge 2 ]] || die "pack requires subcommand"
    sub="$2"; shift 2
    case "$sub" in
      list)    cmd_pack_list "$@" ;;
      status)  cmd_pack_status "$@" ;;
      enable)  cmd_pack_enable "$@" ;;
      disable) cmd_pack_disable "$@" ;;
      *)       die "unknown pack subcommand: $sub" ;;
    esac
    ;;
  model)
    [[ $# -ge 2 ]] || die "model requires subcommand"
    sub="$2"; shift 2
    case "$sub" in
      check)  cmd_model_check ;;
      doctor) cmd_model_doctor ;;
      *)      die "unknown model subcommand: $sub" ;;
    esac
    ;;
  state)
    [[ $# -ge 2 ]] || die "state requires subcommand"
    sub="$2"; shift 2
    case "$sub" in
      show) cmd_state_show "$@" ;;
      *)    die "unknown state subcommand: $sub" ;;
    esac
    ;;
  events)
    shift; cmd_events "$@" ;;
  help|-h|--help)
    usage ;;
  *)
    usage >&2; die "unknown command: $cmd" ;;
esac
